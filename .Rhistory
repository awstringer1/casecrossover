opt_11 <- optimize_all_thetas_parallel(thetagrid2,model_data11,optcontrol = optcontrol)
file.remove("./tmpoutput07687")
sink()
logpost1 <- add_log_posterior_values(opt_1,model_data1)
logpost2 <- add_log_posterior_values(opt_2,model_data2)
logpost3 <- add_log_posterior_values(opt_3,model_data3)
logpost4 <- add_log_posterior_values(opt_4,model_data4)
logpost5 <- add_log_posterior_values(opt_5,model_data5)
logpost6 <- add_log_posterior_values(opt_6,model_data6)
logpost7 <- add_log_posterior_values(opt_7,model_data7)
logpost8 <- add_log_posterior_values(opt_8,model_data8)
logpost9 <- add_log_posterior_values(opt_9,model_data9)
logpost10 <- add_log_posterior_values(opt_10,model_data10)
logpost11 <- add_log_posterior_values(opt_11,model_data11)
logpost1
logpost11
index1 <- get_indices(model_data1)
index3 <- get_indices(model_data3)
index5 <- get_indices(model_data5)
index7 <- get_indices(model_data7)
index9 <- get_indices(model_data9)
index11 <- get_indices(model_data11)
index1
index3
index5
index7
index9
index11
add_log_posterior_values <- function(optresults,model_data) {
optresults <- dplyr::ungroup(optresults)
hessian_structure <- hessian_log_likelihood_structure(rep(0,model_data$Wd),model_data)
# Log posterior for theta
logposttheta <- optresults %>%
purrr::pmap(~log_posterior_theta(unlist(..1),unlist(..4),model_data,hessian_structure)) %>%
purrr::reduce(c)
optresults$theta_logposterior <- logposttheta
optresults <- optresults %>%
dplyr::rowwise() %>%
dplyr::mutate(sigma = list(exp(-.5 * unlist(.data[["theta"]]))),
sigma_logposterior = length(unlist(.data[["sigma"]])) * log(2) - sum(log(unlist(.data[["sigma"]]))) + .data[["theta_logposterior"]])
optresults
}
normalize_log_posterior <- function(pp,tt) {
# pp: log posterior
# tt: theta values at which pp is evaluated. Vector (if single dimension) or list of vectors.
# function returns the LOG of the normalizing constant
# Make sure tt is sorted
if (is.numeric(tt)) {
val <- normalize_log_posterior_single(pp,tt)
return(val)
} else if (is.list(tt)) {
val <- normalize_log_posterior_multiple(pp,tt)
return(val)
} else {
stop("tt values must either be numeric or list.")
}
}
logpost1
logpost11
make_linear_constraints(model_data1)
make_linear_constraints(model_data3)
make_linear_constraints(model_data9)
make_linear_constraints(model_data11)
devtools::test()
get_polynomial_degree
sampledata
names(model_data9)
model_data9$model_elements
model_data9$vectorofcolumnstoremove
model_data10$vectorofcolumnstoremove
controlsmooth4 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = c(1,2),
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
model_data13 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth4)
model_data13$vectorofcolumnstoremove
make_model_lincombs(model_data11)
make_model_lincombs(model_data13)
index13
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/helper_prep-sample-data.R')
index11
index13
make_linear_constraints(model_data11)
make_linear_constraints(model_data13)
devtools::test()
devtools::test()
model_data13$model_elements
make_model_lincombs(model_data13)
logpost1
?inheritParams
normalize_optresults_logpost <- function(optresults) {
thetanormconst <- normalize_log_posterior(optresults$theta_logposterior,optresults$theta)
optresults$theta_logposterior <- optresults$theta_logposterior - thetanormconst
optresults
}
logpost_norm1 <- normalize_optresults_logpost(logpost1)
logpost_norm1
matrixStats::logSumExp(logpost_norm1$theta_logposterior)
normalize_log_posterior(logpost1$theta_logposterior,logpost1$theta)
logpost1
normalize_log_posterior_multiple(logpost1$theta_logposterior,logpost1$theta)
tt <- logpost1$theta
tt
pp <- logpost1$theta_logposterior
pp
M <- length(tt) # Number of grid points
K <- length(tt[[1]]) # Dimension of integration
M
K
df <- tt[[2]][1] - tt[[1]][1]
ww <- log(df) + c(log(1/2),rep(0,M-2),log(1/2))
df
ww
matrixStats::logSumExp(K*ww + pp)
normalize_optresults_logpost(logpost11)
normalize_optresults_logpost(logpost11)$theta_logposterior
normalize_optresults_logpost(logpost11)$theta_logposterior %>% matrixStats::logSumExp()
normalize_optresults_logpost(logpost11)$theta_logposterior %>% exp %>% sum
normalize_log_posterior_single(logpost1$theta_logposterior,c(-1,0,1))
normalize_log_posterior_single(logpost3$theta_logposterior,c(-1,0,1))
logpost3
normalize_log_posterior(dnorm(x1,log=TRUE),x1)
x1
dgamma(x2,1,1,log=TRUE),x2)
normalize_log_posterior(dgamma(x2,1,1,log=TRUE),x2)
normalize_log_posterior(pp1,tt1)
normalize_log_posterior(pp2,tt2)
tt1
packrat::set_opts(external.packages = c("devtools", "ggplot2", "knitr", "usethis", "rmarkdown", "dplyr", "tidyr", "purrr", "stringr", "lubridate", "magrittr", "microbenchmark", "matrixStats", "methods", "mvtnorm", "trustOptim", "parallel", "data.table", "mvQuad"))
packrat::set_opts(external.packages = c("devtools", "ggplot2", "knitr", "usethis", "rmarkdown", "dplyr", "tidyr", "purrr", "stringr", "lubridate", "magrittr", "microbenchmark", "matrixStats", "methods", "mvtnorm", "trustOptim", "parallel", "data.table", "mvQuad"))
library(mvQuad)
nw <- createNIGrid(dim=2, type="GLe", level=6)
nw
getNodes(nw)
getWeights(nw)
rescale(nw, domain = matrix(c(1, 1, 2, 2), ncol=2))
getWeights(nw)
getNodes(nw)
myFun2d <- function(x){
x[,1]*exp(x[,2])
}
A <- quadrature(myFun2d, grid = nw)
A
ww <- getWeights(nw)[ ,1]
ww
pp <- apply(getNodes(nw),myFun2d,1)
pp <- apply(getNodes(nw),1,myFun2d)
getNodes(nw)
apply(getNodes(nw),1,function(x) x)
apply(getNodes(nw),2,myFun2d)
apply(getNodes(nw),1,myFun2d)
myFun2d(c(1,2))
myFun2d(getNodes(nw))
matrixStats::logSumExp(log(ww) + pp)
exp()
exp(matrixStats::logSumExp(log(ww) + pp))
quadrature
sum(ww * exp(pp))
quadrature(myFun2d, grid = nw)
ww <- getWeights(nw)[ ,1]
pp <- myFun2d(getNodes(nw))
nw <- createNIGrid(dim=2, type="GLe", level=6)
rescale(nw, domain = matrix(c(1, 1, 2, 2), ncol=2))
myFun2d <- function(x){
x[,1]*exp(x[,2])
}
quadrature(myFun2d, grid = nw)
ww <- getWeights(nw)[ ,1]
pp <- myFun2d(getNodes(nw))
sum(ww * pp)
sum(ww * exp(pp))
ww <- getWeights(nw)[ ,1]
pp <- log(myFun2d(getNodes(nw)))
sum(ww * exp(pp))
sum(exp(log(ww) + pp))
exp(matrixStats::logSumExp(log(ww) + pp))
nrow(getNodes(createNIGrid(dim=2, type="GLe", level=6)))
nrow(getNodes(createNIGrid(dim=2, type="GLe", level=1)))
nrow(getNodes(createNIGrid(dim=2, type="GLe", level=2)))
nrow(getNodes(createNIGrid(dim=2, type="GLe", level=3)))
nrow(getNodes(createNIGrid(dim=2, type="GLe", level=4)))
nrow(getNodes(createNIGrid(dim=2, type="GLe", level=5)))
nrow(getNodes(createNIGrid(dim=2, type="GLe", level=6)))
?createNIGrid
nw <- createNIGrid(dim=2, type="GLe", level=6,ndConstruction = "sparse")
rescale(nw, domain = matrix(c(1, 1, 2, 2), ncol=2))
myFun2d <- function(x){
x[,1]*exp(x[,2])
}
quadrature(myFun2d, grid = nw)
ww <- getWeights(nw)[ ,1]
pp <- log(myFun2d(getNodes(nw)))
sum(exp(log(ww) + pp))
exp(matrixStats::logSumExp(log(ww) + pp))
ww <- getWeights(nw)[ ,1]
pp <- log(myFun2d(getNodes(nw)))
ww
pp
sum(exp(log(ww) + pp))
exp(matrixStats::logSumExp(log(ww) + pp))
nw <- createNIGrid(dim=2, type="GLe", level=6,ndConstruction = "product")
ww <- getWeights(nw)[ ,1]
pp <- log(myFun2d(getNodes(nw)))
ww
x1 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 6,ndConstruction = "product")
getNodes(x1)
rescale(x1, domain = matrix(c(1, 2), ncol=1))
getNodes(x1)
rescale(x1, domain = matrix(c(-Inf, Inf), ncol=1))
x1
getNodes(x1)
rescale(x1, domain = matrix(c(-10, 10), ncol=1))
getNodes(x1)
x1 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 50,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10, 10), ncol=1))
getNodes(x1)
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 50,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10, 10), ncol=1))
x2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 50,ndConstruction = "product")
rescale(x2, domain = matrix(c(-10, 10), ncol=1))
x3 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 50,ndConstruction = "product")
rescale(x3, domain = matrix(c(-10, 10), ncol=1))
getNodes(x1)
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 50,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
getNodes(x1)
50^3
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 10,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
x2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 10,ndConstruction = "product")
rescale(x2, domain = matrix(c(-10, 10), ncol=1))
x3 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 10,ndConstruction = "product")
rescale(x3, domain = matrix(c(-10, 10), ncol=1))
getNodes(x1)
getNodes(x2)
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 10,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
x2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 10,ndConstruction = "product")
rescale(x2, domain = matrix(c(-10,-10,10,10), ncol=2))
x3 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 10,ndConstruction = "product")
rescale(x3, domain = matrix(c(-10, 10), ncol=1))
getNodes(x1)
getNodes(x2)
getNodes(x)
getNodes(x1)
getNodes(x3)
f1 <- function(x) mvtnorm::dmvnorm(x,log = TRUE)
f2 <- function(x) dgamma(x[1],2,3,log=TRUE) + dgamma(x[2],3,2,log=TRUE)
f3 <- function(x) dnorm(x,0,1,log = TRUE)
f1vals <- f1(getNodes(x1))
f1vals
f2vals <- f2(getNodes(x2))
f3vals <- f3(getNodes(x3))
quadrature(f1,x1)
f1exp <- function(x) exp(f1(x))
f2exp <- function(x) exp(f2(x))
f3exp <- function(x) exp(f3(x))
quadrature(f1exp,x1)
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 50,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
quadrature(f1exp,x1)
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 20,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
quadrature(f1exp,x1)
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 20,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
x2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 20,ndConstruction = "product")
rescale(x2, domain = matrix(c(-10,-10,10,10), ncol=2))
x3 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 20,ndConstruction = "product")
rescale(x3, domain = matrix(c(-10, 10), ncol=1))
f1 <- function(x) mvtnorm::dmvnorm(x,log = TRUE)
f2 <- function(x) dgamma(x[1],2,3,log=TRUE) + dgamma(x[2],3,2,log=TRUE)
f3 <- function(x) dnorm(x,0,1,log = TRUE)
f1exp <- function(x) exp(f1(x))
f2exp <- function(x) exp(f2(x))
f3exp <- function(x) exp(f3(x))
f1vals <- f1(getNodes(x1))
f2vals <- f2(getNodes(x2))
f3vals <- f3(getNodes(x3))
normalize_log_posterior <- function(pp,tt) {
# tt: grid returned by mvQuad::createNIGrid
# pp: log posterior evaluated at these points
ww <- mvQuad::getWeights(tt)
matrixStats::logSumExp(log(ww) + pp)
# # Make sure tt is sorted
# if (is.numeric(tt)) {
#   val <- normalize_log_posterior_single(pp,tt)
#   return(val)
# } else if (is.list(tt)) {
#   val <- normalize_log_posterior_multiple(pp,tt)
#   return(val)
# } else {
#   stop("tt values must either be numeric or list.")
# }
}
normalize_log_posterior(f1vals,x1)
quadrature(f1exp,x1)
1 - quadrature(f1exp,x1)
quadrature
log(quadrature(f1exp,x1))
round(normalize_log_posterior(f1vals,x1),3)
round(normalize_log_posterior(f1vals,x1),2)
devtools::test()
devtools::test()
normalize_log_posterior(f2vals,x2)
quadrature(f2exp,x2)
f2vals
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 20,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
x2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 20,ndConstruction = "product")
rescale(x2, domain = matrix(c(0,0,20,20), ncol=2))
x3 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 20,ndConstruction = "product")
rescale(x3, domain = matrix(c(-10, 10), ncol=1))
f1 <- function(x) mvtnorm::dmvnorm(x,log = TRUE)
f2 <- function(x) dgamma(x[1],2,3,log=TRUE) + dgamma(x[2],3,2,log=TRUE)
f3 <- function(x) dnorm(x,0,1,log = TRUE)
f1exp <- function(x) exp(f1(x))
f2exp <- function(x) exp(f2(x))
f3exp <- function(x) exp(f3(x))
f1vals <- f1(getNodes(x1))
f2vals <- f2(getNodes(x2))
f3vals <- f3(getNodes(x3))
devtools::test()
quadrature(f2exp,x2)
f1 <- function(x) mvtnorm::dmvnorm(x,log = TRUE)
f2 <- function(x) dgamma(x[1],2,3,log=TRUE) + dgamma(x[2],3,2,log=TRUE)
f3 <- function(x) dnorm(x,0,1,log = TRUE)
f1exp <- function(x) exp(f1(x))
f2exp <- function(x) exp(f2(x))
f3exp <- function(x) exp(f3(x))
f1vals <- f1(getNodes(x1))
f2vals <- f2(getNodes(x2))
f3vals <- f3(getNodes(x3))
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 20,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
x2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 20,ndConstruction = "product")
rescale(x2, domain = matrix(c(0,0,20,20), ncol=2))
x3 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 20,ndConstruction = "product")
rescale(x3, domain = matrix(c(-10, 10), ncol=1))
f1 <- function(x) mvtnorm::dmvnorm(x,log = TRUE)
f2 <- function(x) dgamma(x[1],2,3,log=TRUE) + dgamma(x[2],3,2,log=TRUE)
f3 <- function(x) dnorm(x,0,1,log = TRUE)
f1exp <- function(x) exp(f1(x))
f2exp <- function(x) exp(f2(x))
f3exp <- function(x) exp(f3(x))
f1vals <- f1(getNodes(x1))
f2vals <- f2(getNodes(x2))
f3vals <- f3(getNodes(x3))
quadrature(f2exp,x2)
f2exp
getNodes(x2)
f2exp(getNodes(x2))
x1 <- mvQuad::createNIGrid(dim = 3,type = "GLe",level = 20,ndConstruction = "product")
rescale(x1, domain = matrix(c(-10,-10,-10, 10,10,10), ncol=3))
x2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 20,ndConstruction = "product")
rescale(x2, domain = matrix(c(0,0,20,20), ncol=2))
x3 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 20,ndConstruction = "product")
rescale(x3, domain = matrix(c(-10, 10), ncol=1))
f1 <- function(x) mvtnorm::dmvnorm(x,log = TRUE)
f2 <- function(x) dgamma(x[,1],2,3,log=TRUE) + dgamma(x[,2],3,2,log=TRUE)
f3 <- function(x) dnorm(x,0,1,log = TRUE)
f1exp <- function(x) exp(f1(x))
f2exp <- function(x) exp(f2(x))
f3exp <- function(x) exp(f3(x))
f1vals <- f1(getNodes(x1))
f2vals <- f2(getNodes(x2))
f3vals <- f3(getNodes(x3))
devtools::test()
logpost1
xx <- rnorm(10)
xx
attr(xx,"myattr") <- c(1,2,3)
xx
attributes(xx)
attributes(xx)$myattr
class(x1)
inherits(x1,"NIGrid")
pryr::object_size(x1)
pryr::object_size(getNodes(x1))
getNodes(x1)
getNodes(x1) %>% as.list()
getNodes(x1) %>% transpose() %>% map(~reduce(.x,c))
getNodes(x1) %>% purrr::transpose() %>% map(~reduce(.x,c))
nrow(getNodes(x1))
8000*3
split(getNodes(x1))
getNodes(x2)
split(getNodes(x2),rep(1:nrow(getNodes(x2),each = 2)))
split(getNodes(x2),rep(1:nrow(getNodes(x2)),each = 2)))
split(getNodes(x2),rep(1:nrow(getNodes(x2)),each = 2))
getNodes(x2)
split(getNodes(x2),rep(1:nrow(getNodes(x2)),each = 2))
split(getNodes(x2),rep(1:nrow(getNodes(x2)),each = 2))
rep(1:nrow(getNodes(x2)),each = 2)
getNodes(x2)[400, ]
getNodes(x2)[399, ]
xx <- matrix(c(1,2,3,4,5,1,2,3,4,5),ncol=2)
xx
split(xx,rep(1:5,each=2))
split(xx,rep(1:5,2))
rep(1:nrow(getNodes(x2)),2)
split(getNodes(x2),rep(1:nrow(getNodes(x2))2))
split(getNodes(x2),rep(1:nrow(getNodes(x2)),2))
x1
str(x1)
ls(x1)
x1$dim
x1$nodes
mvQuad::createNIGrid(dim = 1,type = "GLe",level = 3)
rescale(thetagrid1,matrix(c(-1,1),ncol=1))
thetagrid1 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 3)
rescale(thetagrid1,matrix(c(-1,1),ncol=1))
thetagrid1$nodes
thetagrid1$weights
thetagrid1 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 3)
thetagrid1$weights
thetagrid1$nodes
rescale(thetagrid1,domain = matrix(c(-1,1),ncol=1))
thetagrid1$nodes
getNodes(thetagrid1)
thetagrid1$nodes
microbenchmark::microbenchmark(getNodes(thetagrid1),thetagrid1$nodes)
thetagrid1 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 3)
rescale(thetagrid1,domain = matrix(c(-1,1),ncol=1))
thetagrid2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 3)
rescale(thetagrid2,domain = matrix(c(-1,-1,1,1),ncol=2))
opt_1 <- optimize_all_thetas_parallel(thetagrid1,model_data1,optcontrol = optcontrol)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/04-optimization.R')
opt_1 <- optimize_all_thetas_parallel(thetagrid1,model_data1,optcontrol = optcontrol)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/04-optimization.R')
opt_1 <- optimize_all_thetas_parallel(thetagrid1,model_data1,optcontrol = optcontrol)
attributes(opt_1)$thetagrid
devtools::test()
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
logpost_norm1 <- normalize_optresults_logpost(logpost1)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
logpost_norm1 <- normalize_optresults_logpost(logpost1)
logpost1 <- add_log_posterior_values(opt_1,model_data1)
logpost1
attributes(logpost1)
attributes(opt_1)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
logpost1 <- add_log_posterior_values(opt_1,model_data1)
attributes(logpost1)
opt_1
attributes(opt_1)
attributes(opt_1)$thetagrid
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
logpost1 <- add_log_posterior_values(opt_1,model_data1)
logpost1
attributes(attributes(optresults)$thetagrid)
attributes(logpost1)
add_log_posterior_values <- function(optresults,model_data) {
optresults <- dplyr::ungroup(optresults)
hessian_structure <- hessian_log_likelihood_structure(rep(0,model_data$Wd),model_data)
# Log posterior for theta
logposttheta <- optresults %>%
purrr::pmap(~log_posterior_theta(unlist(..1),unlist(..4),model_data,hessian_structure)) %>%
purrr::reduce(c)
optresults$theta_logposterior <- logposttheta
out <- optresults %>%
dplyr::rowwise() %>%
dplyr::mutate(sigma = list(exp(-.5 * unlist(.data[["theta"]]))),
sigma_logposterior = length(unlist(.data[["sigma"]])) * log(2) - sum(log(unlist(.data[["sigma"]]))) + .data[["theta_logposterior"]])
attr(out,"thetagrid") <- attributes(optresults)$thetagrid
out
}
logpost1 <- add_log_posterior_values(opt_1,model_data1)
logpost1
attributes(logpost1)
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/helper_prep-sample-data.R')
logpost_norm1
logpost1
logpost_norm1 <- normalize_optresults_logpost(logpost1)
logpost_norm2 <- normalize_optresults_logpost(logpost2)
logpost_norm3 <- normalize_optresults_logpost(logpost3)
logpost_norm4 <- normalize_optresults_logpost(logpost4)
logpost_norm5 <- normalize_optresults_logpost(logpost5)
logpost_norm6 <- normalize_optresults_logpost(logpost6)
logpost_norm7 <- normalize_optresults_logpost(logpost7)
logpost_norm8 <- normalize_optresults_logpost(logpost8)
logpost_norm9 <- normalize_optresults_logpost(logpost9)
logpost_norm10 <- normalize_optresults_logpost(logpost10)
logpost_norm11 <- normalize_optresults_logpost(logpost11)
logpost_norm13 <- normalize_optresults_logpost(logpost13)
logpost_norm10
logpost_norm10$theta_logposterior %>% logSumExp
logpost_norm10$theta_logposterior %>% matrixStats::logSumExp()
devtools::test()
devtools::test()
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/helper_prep-sample-data.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/helper_prep-sample-data.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/helper_prep-sample-data.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-utils.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-prior-definitions.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-utils.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/helper_prep-sample-data.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/01-model-setup.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/helper_prep-sample-data.R')
devtools::test()
devtools::test()
devtools::test()
