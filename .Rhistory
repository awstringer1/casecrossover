model_setup(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-utils.R')
model_setup(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-prior-definitions.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-utils.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/01-model-setup.R')
model_setup(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
library(Matrix)
model_setup(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
casecrossover(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/06-casecrossover.R')
casecrossover(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
model_setup(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
cc3 <- casecrossover(formula = case1 ~ s(x) + strata(id),data = sampledata,control = controlsmooth)
devtools::test()
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/06-casecrossover.R')
cc1 <- casecrossover(case1 ~ x + strata(id),sampledata)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/04-optimization.R')
cc1 <- casecrossover(case1 ~ x + strata(id),sampledata)
formula <- case1 ~ x + strata(id)
data <- sampledata
control = cc_default_control()
model_data <- model_setup(formula,data,control)
# Sort the data by id, case
if (verbose) cat("Sorting data...\n")
data <- data %>% dplyr::arrange(.data[[model_data$model_elements$strata]],.data[[model_data$model_elements$response]])
verbose = FALSE
if (verbose) cat("Setting up model...\n")
model_data <- model_setup(formula,data,control)
# Sort the data by id, case
if (verbose) cat("Sorting data...\n")
data <- data %>% dplyr::arrange(.data[[model_data$model_elements$strata]],.data[[model_data$model_elements$response]])
if (verbose) cat("Creating the grid for numerical integration of theta posterior...\n")
thetagrid <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 3)
mvQuad::rescale(thetagrid,domain = matrix(c(-10,10),ncol=1))
if (verbose) cat("Performing optimization...\n")
opt <- optimize_all_thetas_parallel(thetagrid,
model_data,
optcontrol = model_data$control$opt_control,
doparallel = model_data$control$doparallel)
thetagrid
thetagrid
model_data
optcontrol = model_data$control$opt_control
doparallel = model_data$control$doparallel
# Check thetagrid is formatted correctly
if (!inherits(thetagrid,"NIGrid")) stop("theta should be a NIGrid object returned by mvQuad::createNIgrid()")
# Create the theta list
theta <- split(mvQuad::getNodes(thetagrid),rep(1:nrow(mvQuad::getNodes(thetagrid)),ncol(mvQuad::getNodes(thetagrid))))
if (!all(purrr::map_lgl(theta,is.numeric))) stop("theta should be a list of numeric vectors")
thetalengths <- purrr::map_dbl(theta,length)
if (length(unique(thetalengths)) != 1) stop("Make sure all thetas are the same length.")
if (is.null(optcontrol)) {
optcontrol <- model_data$control$opt_control
}
do_opt <- function(theta) {
cat("Optimizing with theta =",theta,"\n")
optimize_latentfield_trustoptim(theta = theta,
model_data = model_data,
hessian_structure = hessian_structure,
optcontrol = optcontrol)
}
cat("Performing optimization, start time: ", format(Sys.time(),"%H:%M:%S"),"\n")
tm <- proc.time()
if (doparallel) {
opt <- parallel::mclapply(theta,do_opt)
} else {
opt <- lapply(theta,do_opt)
}
opt_time <- proc.time() - tm
opt_time <- unname(opt_time["elapsed"])
cat("Time taken for optimization with ",length(theta)," values of theta:",opt_time,"seconds.\n")
opt
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/02-likelihood.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/03-latent-variables.R')
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
cc1 <- casecrossover(case1 ~ x + strata(id),sampledata)
cc2 <- casecrossover(case2 ~ x + strata(id),sampledata)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-diag-of-inv.R')
cc1 <- casecrossover(case1 ~ x + strata(id),sampledata)
cc2 <- casecrossover(case2 ~ x + strata(id),sampledata)
cc2 <- casecrossover(case2 ~ x + strata(id),sampledata)
cc3 <- casecrossover(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
cc4 <- casecrossover(case2 ~ s(x) + strata(id),sampledata,controlsmooth)
cc5 <- casecrossover(case1 ~ x + s(x) + strata(id),sampledata,controlsmooth)
cc6 <- casecrossover(case2 ~ x + s(x) + strata(id),sampledata,controlsmooth)
cc7 <- casecrossover(case1 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
cc8 <- casecrossover(case2 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
cc9 <- casecrossover(case1 ~ s(x) + s(x2) + poly(x,2,raw = TRUE) + poly(x2,3,raw=TRUE) + strata(id),sampledata,controlsmooth2)
cc10 <- casecrossover(case2 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth2)
cc11 <- casecrossover(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth3)
cc13 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth4)
sampledata <- dplyr::tibble(
id = c(1,1,1,2,2),
case1 = c(0,0,1,0,1),
case2 = c(0,0,2,0,2),
x = c(1,2,3,1,2),
x2 = c(6,2,8,1,0)
)
ff1 <- case1 ~ x + strata(id)
controlsmooth <- cc_control(smooth_prior = list(pc_prior(3,.75)),
linear_constraints = create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"))
controlsmooth2 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = 2,
nm = "x2")
)
)
controlsmooth3 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
controlsmooth4 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = c(1,2),
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
# Case crossover!
cc1 <- casecrossover(case1 ~ x + strata(id),sampledata)
cc2 <- casecrossover(case2 ~ x + strata(id),sampledata)
cc3 <- casecrossover(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
cc4 <- casecrossover(case2 ~ s(x) + strata(id),sampledata,controlsmooth)
cc5 <- casecrossover(case1 ~ x + s(x) + strata(id),sampledata,controlsmooth)
cc6 <- casecrossover(case2 ~ x + s(x) + strata(id),sampledata,controlsmooth)
cc7 <- casecrossover(case1 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
cc8 <- casecrossover(case2 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
cc9 <- casecrossover(case1 ~ s(x) + s(x2) + poly(x,2,raw = TRUE) + poly(x2,3,raw=TRUE) + strata(id),sampledata,controlsmooth2)
cc10 <- casecrossover(case2 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth2)
cc11 <- casecrossover(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth3)
cc13 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth4)
formula <- case1 ~ s(x) + s(x2) + strata(id)
data <- sampledata
control = controlsmooth2
if (verbose) cat("Setting up model...\n")
model_data <- model_setup(formula,data,control)
# Sort the data by id, case
if (verbose) cat("Sorting data...\n")
data <- data %>% dplyr::arrange(.data[[model_data$model_elements$strata]],.data[[model_data$model_elements$response]])
# Choose the theta grid
# TODO: add this to control
if (verbose) cat("Creating the grid for numerical integration of theta posterior...\n")
thetagrid <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 3)
mvQuad::rescale(thetagrid,domain = matrix(c(-10,10),ncol=1))
opt <- optimize_all_thetas_parallel(thetagrid,
model_data,
optcontrol = model_data$control$opt_control,
doparallel = model_data$control$doparallel)
# Check thetagrid is formatted correctly
if (!inherits(thetagrid,"NIGrid")) stop("theta should be a NIGrid object returned by mvQuad::createNIgrid()")
# Create the theta list
theta <- split(mvQuad::getNodes(thetagrid),rep(1:nrow(mvQuad::getNodes(thetagrid)),ncol(mvQuad::getNodes(thetagrid))))
if (!all(purrr::map_lgl(theta,is.numeric))) stop("theta should be a list of numeric vectors")
thetalengths <- purrr::map_dbl(theta,length)
if (length(unique(thetalengths)) != 1) stop("Make sure all thetas are the same length.")
if (is.null(optcontrol)) {
optcontrol <- model_data$control$opt_control
}
do_opt <- function(theta) {
cat("Optimizing with theta =",theta,"\n")
optimize_latentfield_trustoptim(theta = theta,
model_data = model_data,
hessian_structure = hessian_structure,
optcontrol = optcontrol)
}
optcontrol <- model_data$control$opt_control
cat("Performing optimization, start time: ", format(Sys.time(),"%H:%M:%S"),"\n")
tm <- proc.time()
if (doparallel) {
opt <- parallel::mclapply(theta,do_opt)
} else {
opt <- lapply(theta,do_opt)
}
opt_time <- proc.time() - tm
opt_time <- unname(opt_time["elapsed"])
cat("Time taken for optimization with ",length(theta)," values of theta:",opt_time,"seconds.\n")
opt
opt_7 <- optimize_all_thetas_parallel(thetagrid2,model_data7,optcontrol = optcontrol)
opt_7
model_data$model_elements
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-utils.R')
# Create example data for use in testthat tests.
sampledata <- dplyr::tibble(
id = c(1,1,1,2,2),
case1 = c(0,0,1,0,1),
case2 = c(0,0,2,0,2),
x = c(1,2,3,1,2),
x2 = c(6,2,8,1,0)
)
ff1 <- case1 ~ x + strata(id)
controlsmooth <- cc_control(smooth_prior = list(pc_prior(3,.75)),
linear_constraints = create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"))
controlsmooth2 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = 2,
nm = "x2")
)
)
controlsmooth3 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
controlsmooth4 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = c(1,2),
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
model_data1 <- model_setup(case1 ~ x + strata(id),sampledata)
model_data2 <- model_setup(case2 ~ x + strata(id),sampledata)
model_data3 <- model_setup(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
model_data4 <- model_setup(case2 ~ s(x) + strata(id),sampledata,controlsmooth)
model_data5 <- model_setup(case1 ~ x + s(x) + strata(id),sampledata,controlsmooth)
model_data6 <- model_setup(case2 ~ x + s(x) + strata(id),sampledata,controlsmooth)
model_data7 <- model_setup(case1 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
model_data8 <- model_setup(case2 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
model_data9 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2,raw = TRUE) + poly(x2,3,raw=TRUE) + strata(id),sampledata,controlsmooth2)
model_data10 <- model_setup(case2 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth2)
model_data11 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth3)
model_data13 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth4)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/04-optimization.R')
opt <- optimize_all_thetas_parallel(thetagrid,
model_data,
optcontrol = model_data$control$opt_control,
doparallel = model_data$control$doparallel)
if (verbose) cat("Setting up model...\n")
model_data <- model_setup(formula,data,control)
# Sort the data by id, case
if (verbose) cat("Sorting data...\n")
data <- data %>% dplyr::arrange(.data[[model_data$model_elements$strata]],.data[[model_data$model_elements$response]])
# Choose the theta grid
# TODO: add this to control
if (verbose) cat("Creating the grid for numerical integration of theta posterior...\n")
thetagrid <- mvQuad::createNIGrid(dim = length(model_data$model_elements$smooth),type = "GLe",level = model_data$control$thetaaccuracy)
mvQuad::rescale(thetagrid,domain = matrix(c(-10,10),ncol=1))
# Optimization
if (verbose) cat("Performing optimization...\n")
opt <- optimize_all_thetas_parallel(thetagrid,
model_data,
optcontrol = model_data$control$opt_control,
doparallel = model_data$control$doparallel)
# Check thetagrid is formatted correctly
if (!inherits(thetagrid,"NIGrid")) stop("theta should be a NIGrid object returned by mvQuad::createNIgrid()")
# Create the theta list
theta <- split(mvQuad::getNodes(thetagrid),rep(1:nrow(mvQuad::getNodes(thetagrid)),ncol(mvQuad::getNodes(thetagrid))))
if (!all(purrr::map_lgl(theta,is.numeric))) stop("theta should be a list of numeric vectors")
thetalengths <- purrr::map_dbl(theta,length)
if (length(unique(thetalengths)) != 1) stop("Make sure all thetas are the same length.")
if (is.null(optcontrol)) {
optcontrol <- model_data$control$opt_control
}
do_opt <- function(theta) {
cat("Optimizing with theta =",theta,"\n")
optimize_latentfield_trustoptim(theta = theta,
model_data = model_data,
hessian_structure = hessian_structure,
optcontrol = optcontrol)
}
cat("Performing optimization, start time: ", format(Sys.time(),"%H:%M:%S"),"\n")
tm <- proc.time()
if (doparallel) {
opt <- parallel::mclapply(theta,do_opt)
} else {
opt <- lapply(theta,do_opt)
}
opt_time <- proc.time() - tm
opt_time <- unname(opt_time["elapsed"])
cat("Time taken for optimization with ",length(theta)," values of theta:",opt_time,"seconds.\n")
opt
thetagrid
thetagrid <- mvQuad::createNIGrid(dim = length(model_data$model_elements$smooth),type = "GLe",level = model_data$control$thetaaccuracy)
model_data <- model_setup(formula,data,control)
model_data$control$thetaaccuracy
control = cc_default_control()
if (verbose) cat("Setting up model...\n")
model_data <- model_setup(formula,data,control)
control = controlsmooth2
model_data <- model_setup(formula,data,control)
model_data$control$thetaaccuracy
if (verbose) cat("Creating the grid for numerical integration of theta posterior...\n")
thetagrid <- mvQuad::createNIGrid(dim = length(model_data$model_elements$smooth),type = "GLe",level = model_data$control$thetaaccuracy)
mvQuad::rescale(thetagrid,domain = matrix(c(-10,10),ncol=1))
# Optimization
if (verbose) cat("Performing optimization...\n")
opt <- optimize_all_thetas_parallel(thetagrid,
model_data,
optcontrol = model_data$control$opt_control,
doparallel = model_data$control$doparallel)
thetagrid <- mvQuad::createNIGrid(dim = length(model_data$model_elements$smooth),type = "GLe",level = model_data$control$thetaaccuracy)
mvQuad::rescale(thetagrid,domain = matrix(c(-10,10),ncol=1))
thetagrid
if (verbose) cat("Creating the grid for numerical integration of theta posterior...\n")
K <- length(model_data$model_elements$smooth)
thetagrid <- mvQuad::createNIGrid(dim = K,type = "GLe",level = model_data$control$thetaaccuracy)
mvQuad::rescale(thetagrid,domain = matrix(c(rep(-10,K),rep(10,K)),ncol=K))
thetagrid
getNodes(thetagrid)
opt <- optimize_all_thetas_parallel(thetagrid,
model_data,
optcontrol = model_data$control$opt_control,
doparallel = model_data$control$doparallel)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/06-casecrossover.R')
cc1 <- casecrossover(case1 ~ x + strata(id),sampledata)
cc2 <- casecrossover(case2 ~ x + strata(id),sampledata)
cc3 <- casecrossover(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
cc4 <- casecrossover(case2 ~ s(x) + strata(id),sampledata,controlsmooth)
cc5 <- casecrossover(case1 ~ x + s(x) + strata(id),sampledata,controlsmooth)
cc6 <- casecrossover(case2 ~ x + s(x) + strata(id),sampledata,controlsmooth)
cc7 <- casecrossover(case1 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
cc8 <- casecrossover(case2 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
cc9 <- casecrossover(case1 ~ s(x) + s(x2) + poly(x,2,raw = TRUE) + poly(x2,3,raw=TRUE) + strata(id),sampledata,controlsmooth2)
cc10 <- casecrossover(case2 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth2)
cc11 <- casecrossover(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth3)
cc13 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth4)
formula <- case1 ~ x + strata(id)
data <- sampledata
control = cc_default_control()
if (verbose) cat("Setting up model...\n")
model_data <- model_setup(formula,data,control)
# Sort the data by id, case
if (verbose) cat("Sorting data...\n")
data <- data %>% dplyr::arrange(.data[[model_data$model_elements$strata]],.data[[model_data$model_elements$response]])
K <- length(model_data$model_elements$smooth)
K
mvQuad::createNIGrid(dim = 1,type = "GLe",level = 1)
thetagrid <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 1)
getNodes(thetagrid)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/06-casecrossover.R')
cc1 <- casecrossover(case1 ~ x + strata(id),sampledata)
cc2 <- casecrossover(case2 ~ x + strata(id),sampledata)
cc3 <- casecrossover(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
cc4 <- casecrossover(case2 ~ s(x) + strata(id),sampledata,controlsmooth)
cc5 <- casecrossover(case1 ~ x + s(x) + strata(id),sampledata,controlsmooth)
cc6 <- casecrossover(case2 ~ x + s(x) + strata(id),sampledata,controlsmooth)
cc7 <- casecrossover(case1 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
cc8 <- casecrossover(case2 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
cc9 <- casecrossover(case1 ~ s(x) + s(x2) + poly(x,2,raw = TRUE) + poly(x2,3,raw=TRUE) + strata(id),sampledata,controlsmooth2)
cc10 <- casecrossover(case2 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth2)
cc11 <- casecrossover(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth3)
cc13 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth4)
opt_9 <- optimize_all_thetas_parallel(thetagrid2,model_data9,optcontrol = optcontrol)
logpost9 <- add_log_posterior_values(opt_9,model_data9)
posthoc9 <- compute_marginal_means_and_variances(logpost9,model_data9)
posthoc9
formula <- case1 ~ s(x) + s(x2) + poly(x,2,raw = TRUE) + poly(x2,3,raw=TRUE) + strata(id)
data <- sampledata
control = controlsmooth2
model_data <- model_setup(formula,data,control)
# Sort the data by id, case
if (verbose) cat("Sorting data...\n")
data <- data %>% dplyr::arrange(.data[[model_data$model_elements$strata]],.data[[model_data$model_elements$response]])
# Choose the theta grid
# TODO: add this to control
if (verbose) cat("Creating the grid for numerical integration of theta posterior...\n")
K <- length(model_data$model_elements$smooth)
if (K == 0) {
# Create a blank grid as a placeholder
thetagrid <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 1)
} else {
thetagrid <- mvQuad::createNIGrid(dim = K,type = "GLe",level = model_data$control$thetaaccuracy)
mvQuad::rescale(thetagrid,domain = matrix(c(rep(-10,K),rep(10,K)),ncol=K))
}
# Optimization
if (verbose) cat("Performing optimization...\n")
opt <- optimize_all_thetas_parallel(thetagrid,
model_data,
optcontrol = model_data$control$opt_control,
doparallel = model_data$control$doparallel)
opt
opt$theta
posthoc <- compute_marginal_means_and_variances(opt,model_data)
model_results <- opt
i = NULL
constrA = NULL
lincomb = NULL
if (is.null(i)) i <- get_indices(model_data)
if (class(i) == "ccindex") {
idx <- c(i$smooth,i$linear)
} else if (is.numeric(i)) {
idx <- i
} else {
stop(stringr::str_c("i must be an object of class ccindex, or a numeric vector. You provided an object of class ",class(i)))
}
idx <- unname(idx)
# Pull constraints from model_data
if (is.null(constrA)) {
# Check if model has any linear constraints
if (!is.null(model_data$control$linear_constraints)) {
if (length(model_data$control$linear_constraints) > 0) {
constrA <- make_linear_constraints(model_data)
}
}
} else if (!constrA) {
# If constrA is FALSE, nullify it now
constrA <- NULL
} else {
if (!inherits(constrA,"sparseMatrix")) {
stop("constrA must either be NULL, logical, or an object inheriting from sparseMatrix")
}
}
# Pull linear combinations from model data
if (is.null(lincomb)) {
# Check if the model has both linear and smooth terms for the SAME covariate
if (length(intersect(model_data$model_elements$smooth,model_data$model_elements$linear)) > 0) {
lincomb <- make_model_lincombs(model_data)
}
} else if (is.logical(lincomb)) {
# If lincomb set to FALSE, nullify it now
if (!lincomb) lincomb <- NULL
} else {
if (!inherits(lincomb,"sparseMatrix")) {
stop("lincomb must either be NULL, logical, or an object inheriting from sparseMatrix")
}
}
constrA
lincomb
nrow(model_results) > 1
if (nrow(model_results) > 1) {
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,attributes(model_results)$thetagrid)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
# Note that doing this still leaves sigma_logposterior unnormalized! But it's not used in this function.
# Get the integration weights
# dx1 <- diff(model_results$theta) # dx1[i] = x[i+1] - x[i]
# ld <- length(dx1)
# intweights <- c(
#   dx1[1]/2,
#   (dx1[1:(ld-1)] + dx1[2:ld])/2,
#   dx1[ld]/2
# )
intweights <- mvQuad::getWeights(attributes(model_results)$thetagrid)[ ,1]
}
intweights
mvQuad::getNodes(attributes(model_results)$thetagrid)
# Compute the precision matrices for each theta
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = Q_matrix(theta = ..1,model_data = model_data),
theta = ..1)
)
# Compute the hessians for each theta
hessian_structure <- hessian_log_likelihood_structure(W = model_results$solution[[1]],model_data = model_data)
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data,structure = hessian_structure),
theta = ..1)
)
precision_matrices
precision_matrices %>% map("Q") %>% map(rankMatrix)
model_data$vectorofcolumnstoremove
model_data$Wd
precision_matrices %>% map("Q") %>% map(dim)
rm(list=ls())
