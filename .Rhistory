}
# Account for the manual zeroes
if (!is.null(model_data$vectorofcolumnstoremove)) {
if (nm %in% names(model_data$vectorofcolumnstoremove)) {
j <- model_data$vectorofcolumnstoremove[nm]
betavec <- u[j]^(1:degree)
ll <- sparseVector(
x = c(0,betavec), # 0, not 1
i = c(idx[j],linear_idx),
length = model_data$Wd
)
lincomblist <- c(lincomblist,ll)
}
}
}
# Note: the following is not the fastest way to do this. See stackoverflow:
# https://stackoverflow.com/questions/8843700/creating-sparse-matrix-from-a-list-of-sparse-vectors#8844057
# It's about 2x - 3x faster in benchmarking; not worth introducing new code.
lincomblist %>%
purrr::map(~as(.,"sparseMatrix")) %>%
purrr::reduce(cbind)
}
make_model_lincombs(model-data)
make_model_lincombs(model_data)
make_model_lincombs(model_data)[(model_data$Nd+1):model_data$Wd,24:28]
model_data$vectorofcolumnstoremove
u
lenth(u)
length(u)
make_model_lincombs(model_data)[(model_data$Nd+1):model_data$Wd,49:51]
make_model_lincombs(model_data)
model_data$Wd
make_model_lincombs(model_data)[(model_data$Nd+1):model_data$Wd,49:50]
u
length(u)
u <- stitch_zero_vector(u,model_data$vectorofcolumnstoremove[nm])
u
model_data$control$linear_constraints
model_data$control$linear_constraints[[nm]]
model_data$control$linear_constraints[[nm]]$whichzero[1]
u[model_data$vectorofcolumnstoremove[nm]] <- model_data$control$linear_constraints[[nm]]$whichzero[1]
u
lincomblist <- list()
for (nm in terms_to_use) {
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
u <- indices$covvalues[[nm]]
for (j in 1:length(u)) {
betavec <- u[j]^(1:degree)
ll <- sparseVector(
x = c(1,betavec),
i = c(idx[j],linear_idx),
length = model_data$Wd
)
lincomblist <- c(lincomblist,ll)
}
# Account for the manual zeroes
if (!is.null(model_data$vectorofcolumnstoremove)) {
if (nm %in% names(model_data$vectorofcolumnstoremove)) {
u <- stitch_zero_vector(u,model_data$vectorofcolumnstoremove[nm])
u[model_data$vectorofcolumnstoremove[nm]] <- model_data$control$linear_constraints[[nm]]$whichzero[1]
j <- model_data$vectorofcolumnstoremove[nm]
betavec <- u[j]^(1:degree)
ll <- sparseVector(
x = c(0,betavec), # 0, not 1
i = c(idx[j],linear_idx),
length = model_data$Wd
)
lincomblist <- c(lincomblist,ll)
}
}
}
lincomblist %>%
purrr::map(~as(.,"sparseMatrix")) %>%
purrr::reduce(cbind)
order[u]
order(u)
u
u <- indices$covvalues[[nm]]
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
u <- indices$covvalues[[nm]]
for (j in 1:length(u)) {
betavec <- u[j]^(1:degree)
ll <- sparseVector(
x = c(1,betavec),
i = c(idx[j],linear_idx),
length = model_data$Wd
)
lincomblist <- c(lincomblist,ll)
}
u <- c(u,model_data$control$linear_constraints[[nm]]$whichzero[1])
u
betavec <- u[length(u)]^(1:degree)
betavec
sparseVector(
x = betavec, # 0, not 1
i = linear_idx,
length = model_data$Wd
)
# Create the linear combinations
lincomblist <- list()
for (nm in terms_to_use) {
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
u <- indices$covvalues[[nm]]
for (j in 1:length(u)) {
betavec <- u[j]^(1:degree)
ll <- sparseVector(
x = c(1,betavec),
i = c(idx[j],linear_idx),
length = model_data$Wd
)
lincomblist <- c(lincomblist,ll)
}
# Account for the manual zeroes
if (!is.null(model_data$vectorofcolumnstoremove)) {
if (nm %in% names(model_data$vectorofcolumnstoremove)) {
u <- c(u,model_data$control$linear_constraints[[nm]]$whichzero[1])
betavec <- u[length(u)]^(1:degree)
ll <- sparseVector(
x = betavec, # 0, not 1
i = linear_idx,
length = model_data$Wd
)
lincomblist <- c(lincomblist,ll)
}
}
}
outmat <- lincomblist %>%
purrr::map(~as(.,"sparseMatrix")) %>%
purrr::reduce(cbind)
outmat
order(u)
outmat[ ,order(u)]
outmat[ ,order(u)][(model_data$Nd + 1):model_data$Wd, ]
outmat[ ,order(u)][(model_data$Nd + 1):model_data$Wd,20:30]
devtools::test()
devtools::test()
make_model_lincombs(model_data1)
make_model_lincombs(model_data5)
model_data5
make_model_lincombs(model_data5)
make_model_lincombs(model_data9)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
make_model_lincombs(model_data9)
model_data <- model_data9
# Determine the degree of polynomial for each covariate
polydegrees <- get_polynomial_degree(model_data$model_elements$linear_formula)
# Get the indices for all terms
indices <- get_indices(model_data)
smooth_terms <- unique(names(indices$smooth))
linear_terms <- unique(names(indices$linear))
# The terms we use are the terms that appear both in smooth and linear
terms_to_use <- intersect(smooth_terms,linear_terms)
# Create the linear combinations
lincomblist <- list()
terms_to_use
nm <- "x"
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
u <- indices$covvalues[[nm]]
u
model_data$vectorofcolumnstoremove
lincombm
lincombmatrix
xx <- lincombmatrx
xx <- lincombmatrix
xx
ncol(xx)
xx[ ,50] <- rep(0,2748)
xx
nm
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
u <- indices$covvalues[[nm]]
degree
idx
linearidx
linear_idx
u
devtools::test()
make_model_lincombs(model_data9)
model_data9$model_elements
model_data9$control$linear_constraints
model_data <- model_data9
# Check to make sure both linear and smooth terms in the model
if (length(model_data$model_elements$linear) == 0 | length(model_data$model_elements$smooth) == 0) {
stop("You should only be looking at linear combinations if there are both linear and smooth terms in your model.")
}
# Check to see if the SAME term is included as both linear and smooth.
if (length(intersect(model_data$model_elements$linear,model_data$model_elements$smooth)) == 0) {
stop("You have linear and smooth terms in your model, but I don't see any overlap. You should only use this function to create linear combinations for terms in your model that are included as both linear and smooth")
}
# Determine the degree of polynomial for each covariate
polydegrees <- get_polynomial_degree(model_data$model_elements$linear_formula)
# Get the indices for all terms
indices <- get_indices(model_data)
smooth_terms <- unique(names(indices$smooth))
linear_terms <- unique(names(indices$linear))
# The terms we use are the terms that appear both in smooth and linear
terms_to_use <- intersect(smooth_terms,linear_terms)
# Create the linear combinations
lincomblist <- list()
terms_to_use
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
u <- indices$covvalues[[nm]]
degree
nm
idx
linear_idx
u
model_data$control$linear_constraints
u <- model_data$control$linear_constraints[[nm]]$u
u
xx[1,1]
xx[1:3,1:3]
u <- cbind(model_data$control$linear_constraints[[nm]]$u,rep(1,length(model_data$control$linear_constraints[[nm]]$u)))
u
u <- model_data$control$linear_constraints[[nm]]$u
u
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
make_model_lincombs(model_data9)
model_data <- model_data9
if (length(model_data$model_elements$linear) == 0 | length(model_data$model_elements$smooth) == 0) {
stop("You should only be looking at linear combinations if there are both linear and smooth terms in your model.")
}
# Check to see if the SAME term is included as both linear and smooth.
if (length(intersect(model_data$model_elements$linear,model_data$model_elements$smooth)) == 0) {
stop("You have linear and smooth terms in your model, but I don't see any overlap. You should only use this function to create linear combinations for terms in your model that are included as both linear and smooth")
}
# Determine the degree of polynomial for each covariate
polydegrees <- get_polynomial_degree(model_data$model_elements$linear_formula)
# Get the indices for all terms
indices <- get_indices(model_data)
smooth_terms <- unique(names(indices$smooth))
linear_terms <- unique(names(indices$linear))
# The terms we use are the terms that appear both in smooth and linear
terms_to_use <- intersect(smooth_terms,linear_terms)
lincomblist <- list()
for (nm in terms_to_use) {
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
# u <- indices$covvalues[[nm]]
u <- model_data$control$linear_constraints[[nm]]$u
for (j in 1:length(u)) {
betavec <- u[j]^(1:degree)
ll <- sparseVector(
x = c(1,betavec),
i = c(idx[j],linear_idx),
length = model_data$Wd
)
lincomblist <- c(lincomblist,ll)
}
}
nm <- "x"
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
# u <- indices$covvalues[[nm]]
u <- model_data$control$linear_constraints[[nm]]$u
u
idx
indices
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
make_model_lincombs(model_data9)
get_indices(model_data)
model_data$vectorofcolumnstoremove <- NULL
get_indices(model_data)
model_data$M <- model_data$M + 1
model_data$Wd <- model_data$M + model_data$Nd + model_data$p
get_indices(model_data)
formula
model_data <- model_data9
model_data$line
model_data$control$linear_constraints
nm
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
# u <- indices$covvalues[[nm]]
u <- model_data$control$linear_constraints[[nm]]$u
degree
idx
linear_idx
u
model_data1$control$linear_constraints
u <- model_data$control$linear_constraints[[nm]]$u
whichzero <- which(u == model_data$control$linear_constraints[[nm]] == 0)
whichzero <- which(u == model_data$control$linear_constraints[[nm]]$whichzero)
whichzero
u
nm <- "x2"
degree <- polydegrees[names(polydegrees) == nm]
idx <- indices$smooth[names(indices$smooth) == nm]
linear_idx <- indices$linear[names(indices$linear) == nm]
u <- model_data$control$linear_constraints[[nm]]$u
whichzero <- which(u == model_data$control$linear_constraints[[nm]]$whichzero)
u
whichzero
idx
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
devtools::test()
devtools::test()
devtools::test()
devtools::test()
make_model_lincombs(model_data3)
# Create example data for use in testthat tests.
# TODO: there aren't any test cases for smooth models without linear constraints.
sampledata <- dplyr::tibble(
id = c(1,1,1,2,2),
case1 = c(0,0,1,0,1),
case2 = c(0,0,2,0,2),
x = c(1,2,3,1,2),
x2 = c(6,2,8,1,0)
)
ff1 <- case1 ~ x + strata(id)
controlsmooth <- cc_control(smooth_prior = list(pc_prior(3,.75)),
linear_constraints = create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"))
controlsmooth2 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = 2,
nm = "x2")
)
)
controlsmooth3 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
controlsmooth4 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = c(1,2),
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
model_data1 <- model_setup(case1 ~ x + strata(id),sampledata)
model_data2 <- model_setup(case2 ~ x + strata(id),sampledata)
model_data3 <- model_setup(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
model_data4 <- model_setup(case2 ~ s(x) + strata(id),sampledata,controlsmooth)
model_data5 <- model_setup(case1 ~ x + s(x) + strata(id),sampledata,controlsmooth)
model_data6 <- model_setup(case2 ~ x + s(x) + strata(id),sampledata,controlsmooth)
model_data7 <- model_setup(case1 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
model_data8 <- model_setup(case2 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
model_data9 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2,raw = TRUE) + poly(x2,3,raw=TRUE) + strata(id),sampledata,controlsmooth2)
model_data10 <- model_setup(case2 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth2)
model_data11 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth3)
model_data13 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth4)
# Optimization
optcontrol <- cc_control()$opt_control # Defaults
optcontrol$report.freq = 0
optcontrol$report.level = 0
sink("./tmpoutput07687")
opt_single_1_1 <- optimize_latentfield_trustoptim(0,model_data1,optcontrol = optcontrol)
opt_single_1_2 <- optimize_latentfield_trustoptim(-10,model_data1,optcontrol = optcontrol)
opt_single_2_1 <- optimize_latentfield_trustoptim(0,model_data2,optcontrol = optcontrol)
opt_single_2_2 <- optimize_latentfield_trustoptim(-10,model_data2,optcontrol = optcontrol)
opt_single_3_1 <- optimize_latentfield_trustoptim(0,model_data3,optcontrol = optcontrol)
opt_single_3_2 <- optimize_latentfield_trustoptim(-10,model_data3,optcontrol = optcontrol)
opt_single_4_1 <- optimize_latentfield_trustoptim(0,model_data4,optcontrol = optcontrol)
opt_single_4_2 <- optimize_latentfield_trustoptim(-10,model_data4,optcontrol = optcontrol)
opt_single_5_1 <- optimize_latentfield_trustoptim(0,model_data5,optcontrol = optcontrol)
opt_single_5_2 <- optimize_latentfield_trustoptim(-10,model_data5,optcontrol = optcontrol)
opt_single_6_1 <- optimize_latentfield_trustoptim(0,model_data6,optcontrol = optcontrol)
opt_single_6_2 <- optimize_latentfield_trustoptim(-10,model_data6,optcontrol = optcontrol)
opt_single_7_1 <- optimize_latentfield_trustoptim(c(0,0),model_data7,optcontrol = optcontrol)
opt_single_7_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data7,optcontrol = optcontrol)
opt_single_8_1 <- optimize_latentfield_trustoptim(c(0,0),model_data8,optcontrol = optcontrol)
opt_single_8_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data8,optcontrol = optcontrol)
opt_single_9_1 <- optimize_latentfield_trustoptim(c(0,0),model_data9,optcontrol = optcontrol)
opt_single_9_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data9,optcontrol = optcontrol)
opt_single_10_1 <- optimize_latentfield_trustoptim(c(0,0),model_data10,optcontrol = optcontrol)
opt_single_10_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data10,optcontrol = optcontrol)
opt_single_11_1 <- optimize_latentfield_trustoptim(c(0,0),model_data11,optcontrol = optcontrol)
opt_single_11_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data11,optcontrol = optcontrol)
opt_single_13_1 <- optimize_latentfield_trustoptim(c(0,0),model_data13,optcontrol = optcontrol)
opt_single_13_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data13,optcontrol = optcontrol)
file.remove("./tmpoutput07687")
sink()
# thetagrid1 <- list(
#   c(0),c(1),c(-1)
# )
#
# thetagrid2 <- list(
#   c(0,0),c(1,1),c(-1,-1)
# )
thetagrid1 <- mvQuad::createNIGrid(dim = 1,type = "GLe",level = 3)
mvQuad::rescale(thetagrid1,domain = matrix(c(-1,1),ncol=1))
thetagrid2 <- mvQuad::createNIGrid(dim = 2,type = "GLe",level = 3)
mvQuad::rescale(thetagrid2,domain = matrix(c(-1,-1,1,1),ncol=2))
sink("./tmpoutput07687")
opt_1 <- optimize_all_thetas_parallel(thetagrid1,model_data1,optcontrol = optcontrol)
opt_2 <- optimize_all_thetas_parallel(thetagrid1,model_data2,optcontrol = optcontrol)
opt_3 <- optimize_all_thetas_parallel(thetagrid1,model_data3,optcontrol = optcontrol)
opt_4 <- optimize_all_thetas_parallel(thetagrid1,model_data4,optcontrol = optcontrol)
opt_5 <- optimize_all_thetas_parallel(thetagrid1,model_data5,optcontrol = optcontrol)
opt_6 <- optimize_all_thetas_parallel(thetagrid1,model_data6,optcontrol = optcontrol)
opt_7 <- optimize_all_thetas_parallel(thetagrid2,model_data7,optcontrol = optcontrol)
opt_8 <- optimize_all_thetas_parallel(thetagrid2,model_data8,optcontrol = optcontrol)
opt_9 <- optimize_all_thetas_parallel(thetagrid2,model_data9,optcontrol = optcontrol)
opt_10 <- optimize_all_thetas_parallel(thetagrid2,model_data10,optcontrol = optcontrol)
opt_11 <- optimize_all_thetas_parallel(thetagrid2,model_data11,optcontrol = optcontrol)
opt_13 <- optimize_all_thetas_parallel(thetagrid2,model_data13,optcontrol = optcontrol)
file.remove("./tmpoutput07687")
sink()
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/05-posthoc-quantities.R')
make_model_lincombs(model_data3)
# Create example data for use in testthat tests.
# TODO: there aren't any test cases for smooth models without linear constraints.
sampledata <- dplyr::tibble(
id = c(1,1,1,2,2),
case1 = c(0,0,1,0,1),
case2 = c(0,0,2,0,2),
x = c(1,2,3,1,2),
x2 = c(6,2,8,1,0)
)
ff1 <- case1 ~ x + strata(id)
controlsmooth <- cc_control(smooth_prior = list(pc_prior(3,.75)),
linear_constraints = create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"))
controlsmooth2 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = 2,
nm = "x2")
)
)
controlsmooth3 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = 1,
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
controlsmooth4 <- cc_control(
smooth_prior = list(
pc_prior(3,.75),
pc_prior(5,.1)
),
linear_constraints = c(
create_linear_constraints(u = sampledata$x,
whichzero = c(1,2),
nm = "x"),
create_linear_constraints(u = sampledata$x2,
whichzero = c(2,6),
nm = "x2")
)
)
model_data1 <- model_setup(case1 ~ x + strata(id),sampledata)
model_data2 <- model_setup(case2 ~ x + strata(id),sampledata)
model_data3 <- model_setup(case1 ~ s(x) + strata(id),sampledata,controlsmooth)
model_data4 <- model_setup(case2 ~ s(x) + strata(id),sampledata,controlsmooth)
model_data5 <- model_setup(case1 ~ x + s(x) + strata(id),sampledata,controlsmooth)
model_data6 <- model_setup(case2 ~ x + s(x) + strata(id),sampledata,controlsmooth)
model_data7 <- model_setup(case1 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
model_data8 <- model_setup(case2 ~ s(x) + s(x2) + strata(id),sampledata,controlsmooth2)
model_data9 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2,raw = TRUE) + poly(x2,3,raw=TRUE) + strata(id),sampledata,controlsmooth2)
model_data10 <- model_setup(case2 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth2)
model_data11 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth3)
model_data13 <- model_setup(case1 ~ s(x) + s(x2) + poly(x,2) + poly(x2,3) + strata(id),sampledata,controlsmooth4)
devtools::test()
devtools::test()
