W53 <- 1:model_data5$Wd # Nonzero parameter values
W54 <- rnorm(model_data5$Wd) # Random values- ensure this is robust!
W71 <- rep(0,model_data7$Wd)
W72 <- c(rep(0,model_data7$Wd - 1),100000) # The last value, for beta, shouldn't affect the likelihood.
W73 <- 1:model_data7$Wd # Nonzero parameter values
W74 <- rnorm(model_data7$Wd) # Random values- ensure this is robust!
Q11 <- Q_matrix(0,model_data1)
Q12 <- Q_matrix(-5,model_data1)
Q21 <- Q_matrix(0,model_data2)
Q22 <- Q_matrix(-5,model_data2)
Q31 <- Q_matrix(0,model_data3)
Q32 <- Q_matrix(-5,model_data3)
Q51 <- Q_matrix(0,model_data5)
Q52 <- Q_matrix(-5,model_data5)
Q71 <- Q_matrix(c(0,0),model_data7)
Q72 <- Q_matrix(c(-5,-5),model_data7)
log_posterior_theta(0,W51,model_data5)
log_posterior_theta(c(0,0),W71,model_data7)
model_data7$theta_logprior(c(0,1))
model_data7$theta_logprior(c(0,0))
W71
W <- W71
theta <- c(0,0)
model_data <- model_data7
# W is the mode of log_posterior_W(theta)
if (is.null(Q)) {
Q <- Q_matrix(theta,model_data)
}
if (is.null(hessian_structure)) {
hessian_structure <- hessian_log_likelihood_structure(W,model_data)
}
Q_p_C <- -1 * hessian_log_posterior_W(W,Q = Q,model_data = model_data,structure = hessian_structure)
Q_p_C
term1 <- log_likelihood(W,model_data)
dt <- determinant(Q,logarithm = TRUE) # For this, we DO need the determinant
term2_det <- (1/2) * as.numeric(dt$modulus)
term2 <- logprior_W(W,model_data,theta) # Doesn't contain the determinant
term3 <- model_data$theta_logprior(theta)
qcdet <- determinant(Q_p_C,logarithm = TRUE)
term4 <- -(1/2) * as.numeric(qcdet$modulus)
term1
dt
term2_det
term2
term3
qcdet
term3
term4
as.numeric(term1 + term2_det + term2 + term3 + term4)
lpt_inefficient(c(0,0),W71,model_data7)
log_posterior_theta(c(0,0),W71,model_data7)
Q <- Q_matrix(theta,model_data) # Densify for dmvnorm (rolls eyes)
C <- hessian_log_likelihood(W,model_data)
model_data$theta_logprior(theta)
model_data$theta_logprior(theta) +
better_dmvnorm(W = W,mean = rep(0,length(W)),Q = Q)
better_dmvnorm(W = W,mean = rep(0,length(W)),Q = Q)
(1/2)*determinant(Q,logarithm = TRUE)$modulus
dt
determinant(Q,logarithm = TRUE)
determinant(Q,logarithm = TRUE)
Q
Q_matrix(theta,model_data)
rankMatrix(Q)
Q_matrix(c(3,4),model_data)
Q_matrix(c(3,4),model_data) %>% rankMatrix()
model_data$M
model_data$p
model_data$Nd
model_data$vectorofcolumnstoremove
Q_matrix(0,model_data5) %>% rankMatrix()
Q_matrix(0,model_data5)
Q_matrix(0,model_data5) %>% determinant(logarithm = TRUE)
lpt_inefficient(0,W51,model_data5)
log_posterior_theta(0,W51,model_data5)
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/prep-sample-data.R', echo=TRUE)
source('~/phd/projects/case-crossover/rpkg/casecrossover/tests/testthat/prep-sample-data.R', echo=TRUE)
Q_matrix(0,model_data7)
Q_matrix(c(0,0),model_data7)
Q_matrix(c(0,0),model_data7) %>% rankMatrix()
Q_matrix(c(0,0),model_data7) %>% determinant(logarithm = TRUE)
log_posterior_theta(c(0,0),W71,model_data7)
model_data7$Wd
W11 <- rep(0,model_data1$Wd)
W12 <- c(rep(0,model_data1$Wd - 1),100000) # The last value, for beta, shouldn't affect the likelihood.
W13 <- 1:model_data1$Wd # Nonzero parameter values
W14 <- rnorm(model_data1$Wd) # Random values- ensure this is robust!
W21 <- rep(0,model_data2$Wd)
W22 <- c(rep(0,model_data2$Wd - 1),100000) # The last value, for beta, shouldn't affect the likelihood.
W23 <- 1:model_data2$Wd # Nonzero parameter values
W24 <- rnorm(model_data2$Wd) # Random values- ensure this is robust!
W31 <- rep(0,model_data3$Wd)
W32 <- c(rep(0,model_data3$Wd - 1),100000) # The last value, for beta, shouldn't affect the likelihood.
W33 <- 1:model_data3$Wd # Nonzero parameter values
W34 <- rnorm(model_data3$Wd) # Random values- ensure this is robust!
W51 <- rep(0,model_data5$Wd)
W52 <- c(rep(0,model_data5$Wd - 1),100000) # The last value, for beta, shouldn't affect the likelihood.
W53 <- 1:model_data5$Wd # Nonzero parameter values
W54 <- rnorm(model_data5$Wd) # Random values- ensure this is robust!
W71 <- rep(0,model_data7$Wd)
W72 <- c(rep(0,model_data7$Wd - 1),100000) # The last value, for beta, shouldn't affect the likelihood.
W73 <- 1:model_data7$Wd # Nonzero parameter values
W74 <- rnorm(model_data7$Wd) # Random values- ensure this is robust!
Q11 <- Q_matrix(0,model_data1)
Q12 <- Q_matrix(-5,model_data1)
Q21 <- Q_matrix(0,model_data2)
Q22 <- Q_matrix(-5,model_data2)
Q31 <- Q_matrix(0,model_data3)
Q32 <- Q_matrix(-5,model_data3)
Q51 <- Q_matrix(0,model_data5)
Q52 <- Q_matrix(-5,model_data5)
Q71 <- Q_matrix(c(0,0),model_data7)
Q72 <- Q_matrix(c(-5,-5),model_data7)
log_posterior_theta(c(0,0),W71,model_data7)
lpt_inefficient(c(0,0),W71,model_data7)
devtools::test()
devtools::check()
devtools::check()
devtools::check()
cc_control()
model_data1
optimize_latentfield_trustoptim <- function(theta,model_data,hessian_structure = NULL,Q = NULL,trcontrol = NULL) {
# Set up the functions. Negated, functions of W only with other arguments fixed.
optfunc <- function(W) -1 * log_posterior_W(W,theta,model_data,Q)
optfuncgrad <- function(W) -1 * grad_log_posterior_W(W,theta,model_data,Q)
# Get the Q matrix if not provided
if (is.null(Q)) {
Q <- Q_matrix(theta,model_data)
}
# Get the hessian structure, if not provided
if (is.null(hessian_structure)) {
hessian_structure <- hessian_log_likelihood_structure(startingvals,model_data)
}
optfunchess <- function(W) -1 * hessian_log_posterior_W(W,Q = Q,model_data = model_data,structure = hessian_structure,hessian_fd = hessian_fd)
# Set default control arguments if not provided.
# Note: this is really for custom development use only. In the main casecrossover() function, these are set using
# the cc_control() function.
if (is.null(trcontrol)) {
trcontrol <- list(
prec = 1e-02,
stop.trust.radius = sqrt(.Machine$double.eps),
report.freq = report_freq,
report.level = report_level,
start.trust.radius = 1000,
contract.threshold = .25,
contract.factor = .5,
expand.factor = 5,
preconditioner = 1,
trust.iter = 1e08,
cg.tol = 1e-02
)
}
# Perform the optimization
startingvals <- rep(0,model_data$Wd)
opt <- trustOptim::trust.optim(
x = startingvals,
fn = optfunc,
gr = optfuncgrad,
hs = optfunchess,
method = "Sparse",
control = trcontrol
)
# Return a custom-formatted list with optimization results.
# This is done to enable easy stacking of one of these per theta value in a dataframe.
list(
optimizer = list(
name = "trust_optim",
hessian = opt$hessian,
trust_radius = opt$trust.radius,
norm_grad = sqrt(sum(opt$gradient^2)),
scaled_norm_grad = sqrt(sum(opt$gradient^2)) / sqrt(model_data$Wd),
status = opt$status,
nnz = opt$nnz
),
theta = theta,
starting = startingvals,
solution = opt$solution,
function_value = opt$fval,
iterations = opt$iterations
)
}
optimize_latentfield_trustoptim(0,model_data1)
optimize_latentfield_trustoptim <- function(theta,model_data,hessian_structure = NULL,Q = NULL,trcontrol = NULL) {
# Zero is the prior mean. It's a reasonable starting value.
# My experience has been this particular optimization problem is pretty robust to this.
startingvals <- rep(0,model_data$Wd)
# Set up the functions. Negated, functions of W only with other arguments fixed.
optfunc <- function(W) -1 * log_posterior_W(W,theta,model_data,Q)
optfuncgrad <- function(W) -1 * grad_log_posterior_W(W,theta,model_data,Q)
# Get the Q matrix if not provided
if (is.null(Q)) {
Q <- Q_matrix(theta,model_data)
}
# Get the hessian structure, if not provided
if (is.null(hessian_structure)) {
hessian_structure <- hessian_log_likelihood_structure(startingvals,model_data)
}
optfunchess <- function(W) -1 * hessian_log_posterior_W(W,Q = Q,model_data = model_data,structure = hessian_structure,hessian_fd = hessian_fd)
# Set default control arguments if not provided.
# Note: this is really for custom development use only. In the main casecrossover() function, these are set using
# the cc_control() function.
if (is.null(trcontrol)) {
trcontrol <- list(
prec = 1e-02,
stop.trust.radius = sqrt(.Machine$double.eps),
report.freq = report_freq,
report.level = report_level,
start.trust.radius = 1000,
contract.threshold = .25,
contract.factor = .5,
expand.factor = 5,
preconditioner = 1,
trust.iter = 1e08,
cg.tol = 1e-02
)
}
# Perform the optimization
opt <- trustOptim::trust.optim(
x = startingvals,
fn = optfunc,
gr = optfuncgrad,
hs = optfunchess,
method = "Sparse",
control = trcontrol
)
# Return a custom-formatted list with optimization results.
# This is done to enable easy stacking of one of these per theta value in a dataframe.
list(
optimizer = list(
name = "trust_optim",
hessian = opt$hessian,
trust_radius = opt$trust.radius,
norm_grad = sqrt(sum(opt$gradient^2)),
scaled_norm_grad = sqrt(sum(opt$gradient^2)) / sqrt(model_data$Wd),
status = opt$status,
nnz = opt$nnz
),
theta = theta,
starting = startingvals,
solution = opt$solution,
function_value = opt$fval,
iterations = opt$iterations
)
}
optimize_latentfield_trustoptim(0,model_data1)
optimize_latentfield_trustoptim <- function(theta,model_data,hessian_structure = NULL,Q = NULL,trcontrol = NULL) {
# Zero is the prior mean. It's a reasonable starting value.
# My experience has been this particular optimization problem is pretty robust to this.
startingvals <- rep(0,model_data$Wd)
# Set up the functions. Negated, functions of W only with other arguments fixed.
optfunc <- function(W) -1 * log_posterior_W(W,theta,model_data,Q)
optfuncgrad <- function(W) -1 * grad_log_posterior_W(W,theta,model_data,Q)
# Get the Q matrix if not provided
if (is.null(Q)) {
Q <- Q_matrix(theta,model_data)
}
# Get the hessian structure, if not provided
if (is.null(hessian_structure)) {
hessian_structure <- hessian_log_likelihood_structure(startingvals,model_data)
}
optfunchess <- function(W) -1 * hessian_log_posterior_W(W,Q = Q,model_data = model_data,structure = hessian_structure,hessian_fd = hessian_fd)
# Set default control arguments if not provided.
# Note: this is really for custom development use only. In the main casecrossover() function, these are set using
# the cc_control() function.
if (is.null(trcontrol)) {
trcontrol <- list(
prec = 1e-02,
stop.trust.radius = sqrt(.Machine$double.eps),
report.freq = 1,
report.level = 5,
start.trust.radius = 1000,
contract.threshold = .25,
contract.factor = .5,
expand.factor = 5,
preconditioner = 1,
trust.iter = 1e08,
cg.tol = 1e-02
)
}
# Perform the optimization
opt <- trustOptim::trust.optim(
x = startingvals,
fn = optfunc,
gr = optfuncgrad,
hs = optfunchess,
method = "Sparse",
control = trcontrol
)
# Return a custom-formatted list with optimization results.
# This is done to enable easy stacking of one of these per theta value in a dataframe.
list(
optimizer = list(
name = "trust_optim",
hessian = opt$hessian,
trust_radius = opt$trust.radius,
norm_grad = sqrt(sum(opt$gradient^2)),
scaled_norm_grad = sqrt(sum(opt$gradient^2)) / sqrt(model_data$Wd),
status = opt$status,
nnz = opt$nnz
),
theta = theta,
starting = startingvals,
solution = opt$solution,
function_value = opt$fval,
iterations = opt$iterations
)
}
optimize_latentfield_trustoptim(0,model_data1)
packrat::set_opts(external.packages = c("devtools", "ggplot2", "knitr", "usethis", "rmarkdown", "dplyr", "tidyr", "purrr", "stringr", "lubridate", "magrittr", "microbenchmark", "matrixStats", "methods", "mvtnorm", "trustOptim"))
optimize_latentfield_trustoptim(0,model_data1)
hessian_log_posterior_W
optimize_latentfield_trustoptim <- function(theta,model_data,hessian_structure = NULL,Q = NULL,trcontrol = NULL) {
# Zero is the prior mean. It's a reasonable starting value.
# My experience has been this particular optimization problem is pretty robust to this.
startingvals <- rep(0,model_data$Wd)
# Set up the functions. Negated, functions of W only with other arguments fixed.
optfunc <- function(W) -1 * log_posterior_W(W,theta,model_data,Q)
optfuncgrad <- function(W) -1 * grad_log_posterior_W(W,theta,model_data,Q)
# Get the Q matrix if not provided
if (is.null(Q)) {
Q <- Q_matrix(theta,model_data)
}
# Get the hessian structure, if not provided
if (is.null(hessian_structure)) {
hessian_structure <- hessian_log_likelihood_structure(startingvals,model_data)
}
optfunchess <- function(W) -1 * hessian_log_posterior_W(W,Q = Q,model_data = model_data,structure = hessian_structure)
# Set default control arguments if not provided.
# Note: this is really for custom development use only. In the main casecrossover() function, these are set using
# the cc_control() function.
if (is.null(trcontrol)) {
trcontrol <- list(
prec = 1e-02,
stop.trust.radius = sqrt(.Machine$double.eps),
report.freq = 1,
report.level = 5,
start.trust.radius = 1000,
contract.threshold = .25,
contract.factor = .5,
expand.factor = 5,
preconditioner = 1,
trust.iter = 1e08,
cg.tol = 1e-02
)
}
# Perform the optimization
opt <- trustOptim::trust.optim(
x = startingvals,
fn = optfunc,
gr = optfuncgrad,
hs = optfunchess,
method = "Sparse",
control = trcontrol
)
# Return a custom-formatted list with optimization results.
# This is done to enable easy stacking of one of these per theta value in a dataframe.
list(
optimizer = list(
name = "trust_optim",
hessian = opt$hessian,
trust_radius = opt$trust.radius,
norm_grad = sqrt(sum(opt$gradient^2)),
scaled_norm_grad = sqrt(sum(opt$gradient^2)) / sqrt(model_data$Wd),
status = opt$status,
nnz = opt$nnz
),
theta = theta,
starting = startingvals,
solution = opt$solution,
function_value = opt$fval,
iterations = opt$iterations
)
}
hessian_log_posterior_W
optimize_latentfield_trustoptim(0,model_data1)
optimize_latentfield_trustoptim(-10,model_data1)
optimize_latentfield_trustoptim(0,model_data2)
optimize_latentfield_trustoptim(0,model_data3)
optimize_latentfield_trustoptim(0,model_data4)
optimize_latentfield_trustoptim(0,model_data5)
optimize_latentfield_trustoptim(0,model_data6)
optimize_latentfield_trustoptim(0,model_data7)
optimize_latentfield_trustoptim(0,model_data8)
optimize_latentfield_trustoptim(c(0,0),model_data7)
optimize_latentfield_trustoptim(c(0,0),model_data8)
# Optimization for a single theta
opt_single_1_1 <- optimize_latentfield_trustoptim(0,model_data1)
opt_single_1_2 <- optimize_latentfield_trustoptim(-10,model_data1)
opt_single_2_1 <- optimize_latentfield_trustoptim(0,model_data2)
opt_single_2_2 <- optimize_latentfield_trustoptim(-10,model_data2)
opt_single_3_1 <- optimize_latentfield_trustoptim(0,model_data3)
opt_single_3_2 <- optimize_latentfield_trustoptim(-10,model_data3)
opt_single_4_1 <- optimize_latentfield_trustoptim(0,model_data4)
opt_single_4_2 <- optimize_latentfield_trustoptim(-10,model_data4)
opt_single_5_1 <- optimize_latentfield_trustoptim(0,model_data5)
opt_single_5_2 <- optimize_latentfield_trustoptim(-10,model_data5)
opt_single_6_1 <- optimize_latentfield_trustoptim(0,model_data6)
opt_single_6_2 <- optimize_latentfield_trustoptim(-10,model_data6)
opt_single_7_1 <- optimize_latentfield_trustoptim(c(0,0),model_data7)
opt_single_7_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data7)
opt_single_8_1 <- optimize_latentfield_trustoptim(c(0,0),model_data8)
opt_single_8_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data8)
cc_control()
optcontrol <- cc_control()$opt_control # Defaults
optcontrol$report_freq = 0
optcontrol <- cc_control()$opt_control # Defaults
optcontrol$report.freq = 0
optcontrol
optimize_latentfield_trustoptim(0,model_data1,trcontrol = optcontrol)
optcontrol <- cc_control()$opt_control # Defaults
optcontrol$report.freq = 0
optcontrol$report.level = 0
optimize_latentfield_trustoptim(0,model_data1,trcontrol = optcontrol)
sink("./tmpoutput07687")
opt_single_1_1 <- optimize_latentfield_trustoptim(0,model_data1,trcontrol = optcontrol)
opt_single_1_2 <- optimize_latentfield_trustoptim(-10,model_data1)
opt_single_2_1 <- optimize_latentfield_trustoptim(0,model_data2)
opt_single_2_2 <- optimize_latentfield_trustoptim(-10,model_data2)
opt_single_3_1 <- optimize_latentfield_trustoptim(0,model_data3)
opt_single_3_2 <- optimize_latentfield_trustoptim(-10,model_data3)
opt_single_4_1 <- optimize_latentfield_trustoptim(0,model_data4)
opt_single_4_2 <- optimize_latentfield_trustoptim(-10,model_data4)
opt_single_5_1 <- optimize_latentfield_trustoptim(0,model_data5)
opt_single_5_2 <- optimize_latentfield_trustoptim(-10,model_data5)
opt_single_6_1 <- optimize_latentfield_trustoptim(0,model_data6)
opt_single_6_2 <- optimize_latentfield_trustoptim(-10,model_data6)
opt_single_7_1 <- optimize_latentfield_trustoptim(c(0,0),model_data7)
opt_single_7_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data7)
opt_single_8_1 <- optimize_latentfield_trustoptim(c(0,0),model_data8)
opt_single_8_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data8)
sink()
file.remove("./tmpoutput07687")
?file.remove
sink("./tmpoutput07687")
opt_single_1_1 <- optimize_latentfield_trustoptim(0,model_data1,trcontrol = optcontrol)
opt_single_1_2 <- optimize_latentfield_trustoptim(-10,model_data1)
opt_single_2_1 <- optimize_latentfield_trustoptim(0,model_data2)
opt_single_2_2 <- optimize_latentfield_trustoptim(-10,model_data2)
opt_single_3_1 <- optimize_latentfield_trustoptim(0,model_data3)
opt_single_3_2 <- optimize_latentfield_trustoptim(-10,model_data3)
opt_single_4_1 <- optimize_latentfield_trustoptim(0,model_data4)
opt_single_4_2 <- optimize_latentfield_trustoptim(-10,model_data4)
opt_single_5_1 <- optimize_latentfield_trustoptim(0,model_data5)
opt_single_5_2 <- optimize_latentfield_trustoptim(-10,model_data5)
opt_single_6_1 <- optimize_latentfield_trustoptim(0,model_data6)
opt_single_6_2 <- optimize_latentfield_trustoptim(-10,model_data6)
opt_single_7_1 <- optimize_latentfield_trustoptim(c(0,0),model_data7)
opt_single_7_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data7)
opt_single_8_1 <- optimize_latentfield_trustoptim(c(0,0),model_data8)
opt_single_8_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data8)
file.remove("./tmpoutput07687")
sink()
print("hello")
opt_single_1_1
class(opt_single_1_1)
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::check()
devtools::test()
devtools::test()
devtools::test()
cc_control()$optcontrol
cc_control()$opt_control
devtools::test()
cc_control()$opt_control
devtools::test()
devtools::test()
devtools::test()
list(
prec = 1e-08,
stop.trust.radius = sqrt(.Machine$double.eps),
report.freq = 1,
report.level = 1,
start.trust.radius = 1000,
contract.threshold = .25,
contract.factor = .5,
expand.factor = 5,
preconditioner = 1,
trust.iter = 200000,
cg.tol = 1e-06,
maxit = 1000
)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/00-utils.R', echo=TRUE)
source('~/phd/projects/case-crossover/rpkg/casecrossover/R/01-model-setup.R', echo=TRUE)
optcontrol <- cc_control()$opt_control # Defaults
optcontrol$report.freq = 0
optcontrol$report.level = 0
opt_single_1_1 <- optimize_latentfield_trustoptim(0,model_data1,optcontrol = optcontrol)
opt_single_1_2 <- optimize_latentfield_trustoptim(-10,model_data1)
opt_single_1_1
opt_single_1_2
opt_single_2_1 <- optimize_latentfield_trustoptim(0,model_data2)
opt_single_2_2 <- optimize_latentfield_trustoptim(-10,model_data2)
opt_single_3_1 <- optimize_latentfield_trustoptim(0,model_data3)
opt_single_3_2 <- optimize_latentfield_trustoptim(-10,model_data3)
opt_single_4_1 <- optimize_latentfield_trustoptim(0,model_data4)
opt_single_4_2 <- optimize_latentfield_trustoptim(-10,model_data4)
opt_single_5_1 <- optimize_latentfield_trustoptim(0,model_data5)
opt_single_5_2 <- optimize_latentfield_trustoptim(-10,model_data5)
opt_single_6_1 <- optimize_latentfield_trustoptim(0,model_data6)
opt_single_6_2 <- optimize_latentfield_trustoptim(-10,model_data6)
opt_single_7_1 <- optimize_latentfield_trustoptim(c(0,0),model_data7)
opt_single_7_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data7)
opt_single_8_1 <- optimize_latentfield_trustoptim(c(0,0),model_data8)
opt_single_8_2 <- optimize_latentfield_trustoptim(c(-10,-10),model_data8)
devtools::test()
opt_single_7_1
opt_single_7_2
opt_single_8_1
opt_single_8_2
